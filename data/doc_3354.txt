https://en.wikipedia.org/wiki/Enumerated_type

From Wikipedia, the free encyclopedia Named set of data type values "enum" redirects here. For ENUM, see Telephone number mapping . A UML class diagram featuring an enum. In computer programming , an enumerated type (also called enumeration , enum , or factor in the R programming language , a condition-name in the COBOL programming language, a status variable in the JOVIAL programming language, an ordinal in the PL/I programming language , and a categorical variable in statistics) is a data type [ a ] consisting of a set of named values called elements , members , enumeral ,  or enumerators of the type. The enumerator names are usually identifiers that behave as constants in the language. An enumerated type can be seen as a degenerate tagged union of unit type . A variable that has been declared as having an enumerated type can be assigned any of the enumerators as a value. In other words, an enumerated type has values that are different from each other, and that can be compared and assigned, but are not generally [ b ] specified by the programmer  as having any particular concrete representation in the computer's memory ; compilers and interpreters can represent them arbitrarily. Description [ edit ] For example, the four suits in a deck of playing cards may be four enumerators named Club , Diamond , Heart , and Spade , belonging to an enumerated type named suit . If a variable V is declared having suit as its data type, one can assign any of those four values to it. Although the enumerators are usually distinct, some languages may allow the same enumerator to be listed twice in the type's declaration. The names of enumerators need not be semantically complete or compatible in any sense. For example, an enumerated type called color may be defined to consist of the enumerators Red , Green , Zebra , Missing , and Bacon . In some languages, the declaration of an enumerated type also intentionally defines an ordering of its members ( High , Medium and Low priorities); in others, the enumerators are unordered ( English , French , German and Spanish supported languages); in others still, an implicit ordering arises from the compiler concretely representing enumerators as integers. Some enumerator types may be built into the language. The Boolean type for example is often a pre-defined enumeration of the values False and True . A unit type consisting of a single value may also be defined to represent null . Many languages allow users to define new enumerated types. Values and variables of an enumerated type are usually implemented with some integer type as the underlying representation. Some languages, especially system programming languages , allow the user to specify the bit combination to be used for each enumerator, which can be useful to efficiently represent sets of enumerators as fixed-length bit strings. In type theory , enumerated types are often regarded as tagged unions of unit types . Since such types are of the form 1 + 1 + ⋯ + 1 {\displaystyle 1+1+\cdots +1} , they may also be written as natural numbers. Rationale [ edit ] Some early programming languages did not originally have enumerated types. If a programmer wanted a variable, for example myColor , to have a value of red, the variable red would be declared and assigned some arbitrary value, usually an integer constant. The variable red would then be assigned to myColor . Other techniques assigned arbitrary values to strings containing the names of the enumerators. These arbitrary values were sometimes referred to as magic numbers since there often was no explanation as to how the numbers were obtained or whether their actual values were significant. These magic numbers could make the source code harder for others to understand and maintain. Enumerated types, on the other hand, make the code more self-documenting. Depending on the language, the compiler could automatically assign default values to the enumerators thereby hiding unnecessary detail from the programmer. These values may not even be visible to the programmer (see information hiding ). Enumerated types can also prevent a programmer from writing illogical code such as performing mathematical operations on the values of the enumerators. If the value of a variable that was assigned an enumerator were to be printed, some programming languages could also print the name of the enumerator rather than its underlying numerical value. A further advantage is that enumerated types can allow compilers to enforce semantic correctness. For instance: myColor = TRIANGLE can be forbidden, whilst myColor = RED is accepted, even if TRIANGLE and RED are both internally represented with the value 1 . Conceptually, an enumerated type is similar to a list of nominals (numeric codes), since each possible value of the type is assigned a distinctive natural number. A given enumerated type is thus a concrete implementation of this notion. When order is meaningful and/or used for comparison, then an enumerated type becomes an ordinal type. Conventions [ edit ] Programming languages tend to have their own, oftentimes multiple, programming styles and naming conventions . The variable assigned to an enumeration is usually a noun in singular form, and frequently follows either a PascalCase or uppercase convention, while lowercase and others are seen less frequently. Syntax in several programming languages [ edit ] ALGOL 60 based languages [ edit ] While ALGOL 60 itself has no enumeration type, several languages descended from it do. In particular, Pascal had a strong influence on the design of Ada. Pascal [ edit ] In Pascal , an enumerated type can be implicitly declared by listing the values in a parenthesised list: var suit : ( clubs , diamonds , hearts , spades ) ; The declaration will often appear in a type synonym declaration, such that it can be used for multiple variables: type cardsuit = ( clubs , diamonds , hearts , spades ) ; card = record suit : cardsuit ; value : 1 .. 13 ; end ; var hand : array [ 1 .. 13 ] of card ; trump : cardsuit ; The order in which the enumeration values are given matters. An enumerated type is an ordinal type, and the pred and succ functions will give the prior or next value of the enumeration, and ord can convert enumeration values to their integer representation. Standard Pascal does not offer a conversion from arithmetic types to enumerations, however. Extended Pascal offers this functionality via an extended succ function. Some other Pascal dialects allow it via type-casts. Some modern descendants of Pascal, such as Modula-3 , provide a special conversion syntax using a method called VAL ; Modula-3 also treats BOOLEAN and CHAR as special pre-defined enumerated types and uses ORD and VAL for standard ASCII decoding and encoding. Pascal style languages also allow enumeration to be used as array index: var suitcount : array [ cardsuit ] of integer ; Ada [ edit ] In Ada , the definition of enumerated types is similar to Pascal, replacing the use of "=" with "is": type Cardsuit is ( clubs , diamonds , hearts , spades ); In addition to Pred , Succ , Val and Pos Ada also supports simple string conversions via Image and Value . Similar to C-style languages Ada allows the internal representation of the enumeration to be specified: for Cardsuit use ( clubs => 1 , diamonds => 2 , hearts => 4 , spades => 8 ); Ada also allows the number of bits of the enumeration to be specified in a straightforward manner, unlike C-style languages which have inconsistent support often leading to subtle miscompilation errors . [ 1 ] For example: for Cardsuit ' Size use 4 ; -- 4 bits Additionally, one can use enumerations as indexes for arrays, like in Pascal, but there are attributes defined for enumerations Shuffle : constant array ( Cardsuit ) of Cardsuit := ( Clubs => Cardsuit ' Succ ( Clubs ), -- see attributes of enumerations 'First, 'Last, 'Succ, 'Pred Diamonds => Hearts , --an explicit value Hearts => Cardsuit ' Last , --first enumeration value of type Cardsuit e.g., clubs Spades => Cardsuit ' First --last enumeration value of type Cardsuit e.g., spades ); Like Modula-3 Ada treats Boolean and Character as special pre-defined (in package " Standard ") enumerated types. Unlike Modula-3 one can also define own character types: type Cards is (' 7 ', ' 8 ', ' 9 ', ' X ', ' J ', ' Q ', ' K ', ' A '); PL/I [ edit ] Neither the original PL/I nor ANSI ANSI X3.53–1976 has enumerations, but the IBM Enterprise PL/I [ 2 ] has ordinal types. An ordinal variable cannot be used directly as a subscript or as a DO TO limit. However, The type functions first and last , and the builtin functions binaryvalue , ordinalpred and ordinalsucc , allow it indirectly. DO UOTHRU and DO DOWNTO support ordinals define ordinal foo ( green , with , envy ) ; declare ix ordinal foo , bar ( first ( : foo :) : last ( : foo :)) fixed bin ; do i = first ( : foo :) to last ( : foo :) ; bar ( i )= 13 ; end ; do ix = first ( : foo :) upthru last ( : foo :) ; i = binaryvalue ( ix ) ; bar ( i ) = bar ( i ) + 1 ; end ; do ix = first ( : foo :) repeat ordinalsucc ( ix ) until ( ix = first ( : foo :)) /* stop on wrap around. */ ; i = binaryvalue ( ix ) ; display ( bar ( i ) || ' at ' || ix ) ; end ; C and syntactically similar languages [ edit ] C [ edit ] The original K&R dialect of the programming language C had no enumerated types. [ 3 ] In C, enumerations are created by explicit definitions (the enum keyword by itself does not cause allocation of storage) which use the enum keyword and are reminiscent of struct and union definitions: typedef enum { CLUBS , DIAMONDS , HEARTS , SPADES } CardSuit ; typedef struct { CardSuit suit ; short int value ; } Card ; Card hand [ 13 ]; CardSuit trump ; C exposes the integer representation of enumeration values directly to the programmer. Integers and enum values can be mixed freely, and all arithmetic operations on enum values are permitted. It is even possible for an enum variable to hold an integer that does not represent any of the enumeration values. In fact, according to the language definition, the above code will define Clubs , Diamonds , Hearts , and Spades as constants of type int , which will only be converted (silently) to enum CardSuit if they are stored in a variable of that type. C also allows the programmer to choose the values of the enumeration constants explicitly, even without type. For example, enum CardSuit { CLUBS = 1 , DIAMONDS = 2 , HEARTS = 4 , SPADES = 8 }; could be used to define a type that allows mathematical sets of suits to be represented as an enum CardSuit by bitwise logic operations. Since C23 , the underlying type of an enumeration can be specified by the programmer, with the same syntax as C++. [ 4 ] This allows programmers to make optimize enums by choosing a less expensive underlying type. enum CardSuit : char { CLUBS = 1 , DIAMONDS = 2 , HEARTS = 4 , SPADES = 8 }; Enums in C are not scoped or qualified, because C lacks namespacing features. Prior to the introduction of the constexpr keyword in C23, enums were often used to declare compile-time constants without use of the C preprocessor . C# [ edit ] Enumerated types in the C# programming language preserve most of the "small integer" semantics of C's enums. Some arithmetic operations are not defined for enums, but an enum value can be explicitly converted to an integer and back again, and an enum variable can have values that were not declared by the enum definition. For example, given enum CardSuit { Clubs , Diamonds , Spades , Hearts } the expressions CardSuit.Diamonds + 1 and CardSuit.Hearts - CardSuit.Clubs are allowed directly (because it may make sense to step through the sequence of values or ask how many steps there are between two values), but CardSuit.Hearts * CardSuit.Spades is deemed to make less sense and is only allowed if the values are first converted to integers. C# also provides the C-like feature of being able to define specific integer values for enumerations. By doing this it is possible to perform binary operations on enumerations, thus treating enumeration values as sets of flags. These flags can be tested using binary operations or with the enum type's builtin ' HasFlag ' method. [ 5 ] The enumeration definition defines names for the selected integer values and is syntactic sugar , as it is possible to assign to an enum variable other integer values that are not in the scope of the enum definition. [ 6 ] [ 7 ] [ 8 ] C++ [ edit ] C++ has enumeration types that are directly inherited from C's and work mostly like these, except that an enumeration is a real type in C++, giving added compile-time checking. Also (as with structs), the C++ enum keyword is combined with a typedef , so that instead of referring to the type as enum MyEnum , one can simply refer to it as MyEnum . This can be simulated in C using a typedef: typedef enum { VALUE_1 , VALUE_2 } MyEnum ; C++11 also provides a second kind of enumeration, called a scoped enumeration . These are type-safe: the enumerators are not implicitly converted to an integer type. Among other things, this allows I/O streaming to be defined for the enumeration type. Another feature of scoped enumerations is that the enumerators must be qualified by the enum name, so usage requires prefixing with the name of the enumeration (e.g., Color::RED for the first enumerator in the example below), unless a using enum declaration (introduced in C++20 ) has been used to bring the enumerators into the current scope. A scoped enumeration is specified by the phrase enum class (or enum struct ). For example: // C-style unscoped enum enum CardSuit { CLUBS , DIAMONDS , SPADES , HEARTS }; // C++11-style scoped enum enum class Color { RED , GREEN , BLUE }; int main ( int argc , char * argv []) { Color c = Color :: RED ; // Unscoped C-style enum CardSuit card1 = Clubs ; // Can be unscoped CardSuit card2 = CardSuit :: SPADES ; // Usually declared scoped however } The underlying type of an enumeration is an implementation-defined integral type that is large enough to hold all enumerated values; it does not have to be the smallest possible type. The underlying type can be specified directly, which allows "forward declarations" of enumerations: // must fit in size and memory layout the type 'long' enum class Color : long { RED , GREEN , BLUE }; // forward declaration. If later there are values defined // that don't fit in 'char' it is an error. enum class Shapes : char ; Go [ edit ] Go uses the iota keyword to create enumerated constants. [ 9 ] [ 10 ] type ByteSize int const ( _ = iota // ignore first value by assigning to blank identifier; 0 KB ByteSize = 1 << ( 10 * iota ) // 1 << (10 * 1) == 1 << 10 == 1024; in binary 10000000000 MB // 1 << (10 * 2) == 1048576;                                     in binary 100000000000000000000 GB // 1 << (10 * 3) == 1073741824;                                  in binary 1000000000000000000000000000000 ) Java [ edit ] The J2SE version 5.0 of the Java programming language added enumerated types whose declaration syntax is
similar to that of C : enum CardSuit { CLUBS , DIAMONDS , SPADES , HEARTS }; CardSuit trump ; The Java type system, however, treats enumerations as a type separate from integers, and intermixing of enum and integer values is not allowed. In fact, an enum type in Java is actually a special compiler-generated class rather than an arithmetic type, and enum values behave as global pre-generated instances of that class. Enum types can have instance methods and a constructor (the arguments of which can be specified separately for each enum value). All enum types implicitly extend the Enum abstract class, and thus an enum cannot extend anything else. An enum type cannot be instantiated directly. [ 11 ] Internally, each enum value contains an integer, corresponding to the order in which they are declared in the source code, starting from 0. The programmer cannot set a custom integer for an enum value directly, but one can define overloaded constructors that can then assign arbitrary values to self-defined members of the enum class. Defining getters allows then access to those self-defined members. The internal integer can be obtained from an enum value using the ordinal() method, and the list of enum values of an enumeration type can be obtained in order using the values() method. It is generally discouraged for programmers to convert enums to integers and vice versa. [ 12 ] Enumerated types are Comparable , using the internal integer; as a result, they can be sorted. The Java standard library provides utility classes to use with enumerations. The EnumSet class implements a Set of enum values; it is implemented as a bit array , which makes it very compact and as efficient as explicit bit manipulation, but safer. The EnumMap class implements a Map of enum values to object. It is implemented as an array, with the integer value of the enum value serving as the index. Unlike C++, Java enums can have methods, constructors, and fields like any other class. public enum Planet { // Planet, followed by mass and radius MERCURY ( 3.303e+23 , 2.4397e6 ), VENUS ( 4.869e+24 , 6.0518e6 ), EARTH ( 5.976e+24 , 6.37814e6 ), MARS ( 6.421e+23 , 3.3972e6 ), JUPITER ( 1.9e+27 , 7.1492e7 ), SATURN ( 5.688e+26 , 6.0268e7 ), URANUS ( 8.686e+25 , 2.5559e7 ), NEPTUNE ( 1.024e+26 , 2.4746e7 ); public static final double G = 6.67300E-11 ; private final double mass ; private final double radius ; Planet ( double mass , double radius ) { this . mass = mass ; this . radius = radius ; } private double mass () { return mass ; } private double radius () { return radius ; } double surfaceGravity () { return G * mass / ( radius * radius ); } double surfaceWeight ( double otherMass ) { return otherMass * surfaceGravity (); } public static void main ( String [] args ) { double earthWeight = Double . parseDouble ( args [ 0 ] ); double mass = earthWeight / EARTH . surfaceGravity (); for ( Planet p : Planet . values ()) { System . out . printf ( "Your weight on %s is %f%n" , p , p . surfaceWeight ( mass ) ); } } } Perl [ edit ] Dynamically typed languages in the syntactic tradition of C (e.g., Perl or JavaScript ) do not, in general, provide enumerations.  But in Perl programming the same result can be obtained with the shorthand strings list and hashes (possibly slices ): my @enum = qw(Clubs Diamonds Hearts Spades) ; my ( %set1 , %set2 ); @set1 { @enum } = (); # all cleared @set2 { @enum } = ( 1 ) x @enum ; # all set to 1 $set1 { Clubs } ... # false $set2 { Diamonds } ... # true Raku [ edit ] Raku (formerly known as Perl 6) supports enumerations. There are multiple ways to declare enumerations in Raku, all creating a back-end Map. enum Cat <sphynx siamese bengal shorthair other> ; # Using "quote-words" enum Cat ( 'sphynx' , 'siamese' , 'bengal' , 'shorthair' , 'other' ); # Using a list enum Cat ( sphynx => 0 , siamese => 1 , bengal => 2 , shorthair => 3 , other => 4 ); # Using Pair constructors enum Cat (: sphynx ( 0 ), : siamese ( 1 ), : bengal ( 2 ), shorthair ( 3 ), : other ( 4 )); # Another way of using Pairs, you can also use `:0sphynx` PHP [ edit ] Enums were added in PHP version 8.1. enum CardSuit { case Hearts ; case Diamonds ; case Clubs ; case Spades ; } Enumerators may be backed by string or integer values to aid serialization: enum CardSuit : string { case Hearts = 'H' ; case Diamonds = 'D' ; case Clubs = 'C' ; case Spades = 'S' ; } The Enum's interface exposes a method that gives a collection of its enumerators and their names. String/integer-backed Enums also expose the backing value and methods to (attempt) deserialization. Users may add further methods. Rust [ edit ] Though Rust uses the enum keyword like C, it uses it to describe tagged unions , of which enums can be considered a degenerate form. Rust's enums are therefore much more flexible and can contain struct and tuple variants. enum Message { Quit , Move { x : i32 , y : i32 }, // struct Write ( String ), // single-element tuple ChangeColor ( i32 , i32 , i32 ), // three-element tuple } Like C, Rust also supports specifying the values of each variant, pub enum Weekday { Sunday = 1 , Monday = 2 , Tuesday = 4 , Wednesday = 8 , Thursday = 16 , Friday = 32 , Saturday = 64 , } Swift [ edit ] In C, enumerations assign related names to a set of integer values. In Swift , enumerations are much more flexible and need not provide a value for each case of the enumeration. If a value (termed a raw value) is provided for each enumeration case, the value can be a string, a character, or a value of any integer or floating-point type. Alternatively, enumeration cases can specify associated values of any type to be stored along with each different case value, much as unions or variants do in other languages. One can define a common set of related cases as part of one enumeration, each of which has a different set of values of appropriate types associated with it. In Swift, enumerations are a first-class type. They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration's current value, and instance methods to provide functionality related to the values the enumeration represents. Enumerations can also define initializers to provide an initial case value and can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality. enum CardSuit { case clubs case diamonds case hearts case spades } Unlike C and Objective-C , Swift enumeration cases are not assigned a default integer value when they are created. In the CardSuit example above, clubs, diamonds, hearts, and spades do not implicitly equal 0, 1, 2 and 3. Instead, the different enumeration cases are fully-fledged values in their own right, with an explicitly defined type of CardSuit. Multiple cases can appear on a single line, separated by commas: enum CardSuit { case clubs , diamonds , hearts , spades } When working with enumerations that store integer or string raw values, one doesn't need to explicitly assign a raw value for each case because Swift will automatically assign the values. For instance, when integers are used for raw values, the implicit value for each case is one more than the previous case. If the first case doesn't have a value set, its value is 0. For the CardSuit example, suits can be numbered starting from 1 by writing: enum CardSuit { case clubs = 1 , diamonds , hearts , spades } TypeScript [ edit ] TypeScript adds an 'enum' data type to JavaScript. enum CardSuit { Clubs , Diamonds , Hearts , Spades }; var c : CardSuit = CardSuit . Diamonds ; By default, enums number members starting at 0; this can be overridden by setting the value of the first: enum CardSuit { Clubs = 1 , Diamonds , Hearts , Spades }; var c : CardSuit = CardSuit . Diamonds ; All the values can be set: enum CardSuit { Clubs = 1 , Diamonds = 2 , Hearts = 4 , Spades = 8 }; var c : CardSuit = CardSuit . Diamonds ; TypeScript supports mapping the numeric value to its name. For example, this finds the name of the value 2: enum CardSuit { Clubs = 1 , Diamonds , Hearts , Spades }; var suitName : string = CardSuit [ 2 ]; alert ( suitName ); Python [ edit ] An enum module was added to the Python standard library in version 3.4. It introduces the class Enum which can be extended for defining enumerated types. from enum import Enum class CardSuit ( Enum ): CLUBS : int = 1 DIAMONDS : int = 2 HEARTS : int = 3 SPADES : int = 4 There is also a functional API for creating enumerations with automatically generated indices (starting with one): Cards : Enum = Enum ( "Cards" , "CLUBS DIAMONDS HEARTS SPADES" ) Python enumerations do not enforce semantic correctness (a meaningless comparison to an incompatible enumeration always returns False rather than raising a TypeError ): Color : Enum = Enum ( "Color" , "RED GREEN BLUE" ) Shape : Enum = Enum ( "Shape" , [ "CIRCLE" , "TRIANGLE" , "SQUARE" , "HEXAGON" ]) def has_vertices ( shape : Enum ) -> bool : return shape != Shape . CIRCLE if __name__ == "__main__" : has_vertices ( Color . GREEN ) # outputs "True" Dart [ edit ] Dart has a support for the most basic form of enums and has a syntax similar to other languages supporting enums. enum CardSuit { Clubs , Diamonds , Hearts , Spades } void main () { CardSuit card = CardSuit . Clubs ; // Dart uses the "switch" operator to match the value of an enum with the desired output. switch ( card ) { case CardSuit . Clubs: { print ( "Clubs" ); } break ; case CardSuit . Diamonds: { print ( "Diamonds" ); } break ; case CardSuit . Hearts: { print ( "Hearts" ); } break ; case CardSuit . Spades: { print ( "Spades" ); } break ; default : { print ( "Unknown" ); } break ; } } Note that before Dart 3, [ 13 ] the switch operator did not guarantee the completeness of the cases. This means if you omit one case, the compiler will not raise an error. Other programming languages [ edit ] COBOL [ edit ] In COBOL a condition-variable is a normal variable with subordinate level-88 fields, known as condition-names. Each condition-name must have a VALUE clause. The VALUE clause for a condition clause may specify either a single value or a list of values. Fortran [ edit ] Fortran 2003 introduced enumerators for interoperability with C; hence, the semantics is similar to C and, as in C, the enum values are just integers and no further type check is done. The C example from above can be written in Fortran as enum , bind ( C ) enumerator :: CLUBS = 1 , DIAMONDS = 2 , HEARTS = 4 , SPADES = 8 end enum Fortran 2023 introduced a true enumeration type.  Values are ordered sequentially as specified.  Intrinsic functions int and huge support enumerations.  The functions next and previous are also available. enumeration type :: days_of_week enumerator :: monday , tuesday , wednesday , thursday , friday enumerator :: saturday , sunday end enumeration type type ( days_of_week ) :: dow : if ( dow == wednesday ) then print * , 'hump day' end if : select case ( dow ) case ( monday : friday ) print * , 'weekday' case ( saturday , sunday ) print * , 'weekend' end select Microsoft Visual Basic family [ edit ] Visual Basic (classic) and VBA VB.NET VBScript Enum CardSuit ' Zero-based Clubs Diamonds Hearts Spades End Enum Sub EnumExample () Dim suit As CardSuit suit = Diamonds MsgBox suit End Sub Enumerated datatypes are automatically assigned the " Long " datatype and also become a datatype themselves Enum CardSuit Clubs Diamonds Hearts Spades End Enum Sub EnumExample () Dim suit As CardSuit suit = CardSuit . Diamonds MessageBox . show ( suit ) End Sub Not available Lisp [ edit ] Common Lisp uses the member type specifier, e.g., ( deftype cardsuit () ' ( member club diamond heart spade )) that states that object is of type cardsuit if it is #'eql to club, diamond, heart or spade. The member type specifier is not valid as a Common Lisp Object System (CLOS) parameter specializer, however. Instead, (eql atom) , which is the equivalent to (member atom) may be used (that is, only one member of the set may be specified with an eql type specifier, however, it may be used as a CLOS parameter specializer.) In other words, to define methods to cover an enumerated type, a method must be defined for each specific element of that type. Additionally, ( deftype finite-element-set-type ( &rest elements ) ` ( member ,@ elements )) may be used to define arbitrary enumerated types at runtime. For instance ( finite-element-set-type club diamond heart spade ) would refer to a type equivalent to the prior definition of cardsuit, as of course would simply have been using ( member club diamond heart spade ) but may be less confusing with the function #'member for stylistic reasons. Algebraic data type in functional programming [ edit ] In functional programming languages in the ML lineage (e.g., Standard ML (SML), OCaml , and Haskell ), an algebraic data type with only nullary constructors can be used to implement an enumerated type. For example (in the syntax of SML signatures): datatype cardsuit = Clubs | Diamonds | Hearts | Spades type card = { suit : cardsuit ; value : int } val hand : card list val trump : cardsuit In these languages the small-integer representation is completely hidden from the programmer, if indeed such a representation is employed by the implementation. However, Haskell has the Enum type class which a type can derive or implement to get a mapping between the type and Int . Databases [ edit ] Some databases support enumerated types directly. MySQL provides an enumerated type ENUM with allowable values specified as strings when a table is created. The values are stored as numeric indices with the empty string stored as 0, the first string value stored as 1, the second string value stored as 2, etc. Values can be stored and retrieved as numeric indexes or string values. [ 14 ] Example: CREATE TABLE shirts ( name VARCHAR ( 40 ), size ENUM ( 'x-small' , 'small' , 'medium' , 'large' , 'x-large' ) ); JSON Schema [ edit ] Can be defined in JSON schema using the "enum" keyword. [ 15 ] { "$schema" : "https://json-schema.org/draft/2020-12/schema" , "type" : "object" , "properties" : { "cardsuit" : { "type" : "string" , "enum" : [ "Clubs" , "Diamonds" , "Hearts" , "Spades" ] } }, "required" : [ "cardsuit" ] } XML Schema [ edit ] XML Schema supports enumerated types through the enumeration facet used for constraining most primitive datatypes such as strings. <xs:element name= "cardsuit" > <xs:simpleType> <xs:restriction base= "xs:string" > <xs:enumeration value= "Clubs" /> <xs:enumeration value= "Diamonds" /> <xs:enumeration value= "Hearts" /> <xs:enumeration value= "Spades" /> </xs:restriction> </xs:simpleType> </xs:element> See also [ edit ] Contrast set Notes [ edit ] ^ In COBOL , a variable of any type can serve as an enumeration if it is followed by condition-name (88-level) definitions. ^ In some languages explicit values are allowed, and in a few they are even required. References [ edit ] ^ Wander, Costa. "Highway to hell: C++ enums and bit fields › Wander Lairson Costa" . walac.github.io . Retrieved 26 September 2025 . ^ "Coded arithmetic data and attributes" (PDF) . Enterprise PL/I for z/OS 6.2 Language Reference (PDF) . IBM . 2025. pp. 28-29 . SC31-5716-00 . Retrieved July 8, 2025 . ^ Kernighan, Brian W. ; Ritchie, Dennis M. (February 1978). The C Programming Language (1st ed.). Englewood Cliffs, NJ : Prentice Hall . ISBN 0-13-110163-3 . ^ "WG14-N3030 : Enhancements to Enumerations" . 2022-07-19. ^ "Enum.HasFlag(Enum) Method (System)" . learn.microsoft.com . Retrieved 6 December 2024 . ^ Obasanjo, Dare (2007). "A Comparison of Microsoft's C# Programming Language to Sun Microsystems' Java Programming Language" . Archived from the original on 2012-09-10 . Retrieved 2012-09-06 . In Java, enumerated types are a full fledged class which means they are typesafe and can be extended by adding methods, fields or even implementing interfaces. Whereas in C#, an enumerated type is simply syntactic sugar around an integral type (typically an int) meaning they cannot be extended and are not typesafe. {{ cite web }} :  CS1 maint: bot: original URL status unknown ( link ) ^ Gruntz, Dominik, Prof. Dr. (2005-04-08). "Java 5: Taming the Tiger: Syntactic Sugar" (in German). Fachhochschule Aargau, Nordwestschweiz. Archived from the original on 2007-01-07 . Retrieved 2012-09-10 . Enumerationen sind die heimlichen Sieger von Java 1.5. Nach vielen Beteuerungen durch Sun, Enums seien in Java überflüssig und können einfach nachgebildet werden, wurden sie nun doch eingeführt. Die einfachste Möglichkeit einer Enumeration der Jahreszeiten  sieht wie folgt aus … Das Schlüsselwort  enum steht für eine spezielle Art von Klasse, die eine Enumeration  definiert. … Im Gegensatz zu anderen Programmiersprachen wie C/C++ und C# kann man ihnen per Gleichheitszeichen keine ganzen Zahlen zuordnen. {{ cite web }} :  CS1 maint: multiple names: authors list ( link ) Alt URL Archived 2013-05-27 at the Wayback Machine ^ Truter, Christoff (2011-08-04). "Syntactic sugar (C#): Enum" . CSTrüter. Archived from the original on 2007-01-07 . Retrieved 2012-09-10 . // Poorly designed enum don't do this … Obviously (like with everything else), we can misuse this piece of sugar ending up with a system suffering from hyperglycemia. … Seeing as the underlying type of our enum is an int (can also use other integral types) it can lead to some interesting issues when using an enum as bit flags via bitwise operators. {{ cite web }} :  CS1 maint: bot: original URL status unknown ( link ) ^ "Effective Go" . golang.org . The Go Authors . Retrieved 2014-05-13 . ^ "Go Wiki: Iota - The Go Programming Language" . go.dev . Retrieved 2025-05-15 . Go's iota identifier is used in const declarations to simplify definitions of incrementing numbers. Because it can be used in expressions, it provides a generality beyond that of simple enumerations ^ "Enum Types" . Oracle . Retrieved 2013-12-05 . ^ Bloch, Joshua (2008). Effective Java (Second ed.). Upper Saddle River, N.J.: Addison-Wesley. p. 158 . ISBN 978-0-321-35668-0 . ^ "language/accepted/3.0/patterns/exhaustiveness.md at main · dart-lang/language" . GitHub . Archived from the original on 2024-12-03 . Retrieved 2025-06-20 . ^ "MySQL :: MySQL 8.0 Reference Manual :: 11.3.5 The ENUM Type" . dev.mysql.com . Retrieved 19 September 2021 . ^ Wright, Austin. "JSON Schema Validation: A Vocabulary for Structural Validation of JSON" . json-schema.org . Retrieved 22 June 2025 . External links [ edit ] The Wikibook Ada Programming has a page on the topic of: Enumeration Enumerated types in C/C++ Enumerated types in C# Enumerated types in Java Enumerated types in MySQL Enumerated types in Obix Enumerated types in PHP Enumerated types in Swift Enumerated types in XML Enumerated types in Visual Basic v t e Data types Uninterpreted Bit Byte Trit Tryte Word Bit array Numeric Arbitrary-precision or bignum Complex Decimal Fixed point Block floating point Floating point Reduced precision Minifloat Half precision bfloat16 Single precision Double precision Quadruple precision Octuple precision Extended precision Long double Integer signedness Interval Rational Pointer Address physical virtual Reference Text Character String null-terminated Composite Algebraic data type generalized Array Associative array Class Dependent Equality Inductive Intersection List Object metaobject Option type Product Record or Struct Refinement Set Union tagged Other Any type Boolean Bottom type Collection Enumerated type Exception Function type Opaque data type Recursive data type Semaphore Stream Strongly typed identifier Type class Empty type Unit type Void Related topics Value Abstract data type Boxing Data structure Generic Kind metaclass Parametric polymorphism Primitive data type Interface Subtyping Type constructor Type conversion Type system Type theory Variable Retrieved from " https://en.wikipedia.org/w/index.php?title=Enumerated_type&oldid=1322445627 " Categories : Data types Type theory Hidden categories: CS1 maint: bot: original URL status unknown CS1 maint: multiple names: authors list CS1 German-language sources (de) Webarchive template wayback links Articles with short description Short description is different from Wikidata Articles with example Ada code Articles with example Python (programming language) code